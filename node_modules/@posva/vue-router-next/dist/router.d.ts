import { BaseHistory } from './history/base';
import { RouteLocation, RouteRecord, RouteLocationNormalized, ListenerRemover, NavigationGuard, PostNavigationGuard, MatcherLocation, RouteQueryAndHash } from './types/index';
export interface RouterOptions {
    history: BaseHistory;
    routes: RouteRecord[];
}
declare type ErrorHandler = (error: any) => any;
export declare class Router {
    protected history: BaseHistory;
    private matcher;
    private beforeGuards;
    private afterGuards;
    currentRoute: Readonly<RouteLocationNormalized>;
    pendingLocation: Readonly<RouteLocationNormalized>;
    private app;
    private errorHandlers;
    constructor(options: RouterOptions);
    matchLocation(location: MatcherLocation & Required<RouteQueryAndHash>, currentLocation: RouteLocationNormalized, redirectedFrom?: RouteLocationNormalized): RouteLocationNormalized;
    /**
     * Trigger a navigation, adding an entry to the history stack. Also apply all navigation
     * guards first
     * @param to where to go
     */
    push(to: RouteLocation): Promise<RouteLocationNormalized>;
    /**
     * Trigger a navigation, replacing current entry in history. Also apply all navigation
     * guards first
     * @param to where to go
     */
    replace(to: RouteLocation): Promise<RouteLocationNormalized>;
    /**
     * Runs a guard queue and handles redirects, rejections
     * @param guards Array of guards converted to functions that return a promise
     * @returns {boolean} true if the navigation should be cancelled false otherwise
     */
    private runGuardQueue;
    private navigate;
    /**
     * Add a global beforeGuard that can confirm, abort or modify a navigation
     * @param guard
     */
    beforeEach(guard: NavigationGuard): ListenerRemover;
    /**
     * Add a global after guard that is called once the navigation is confirmed
     * @param guard
     */
    afterEach(guard: PostNavigationGuard): ListenerRemover;
    /**
     * Add an error handler to catch errors during navigation
     * TODO: return a remover like beforeEach
     * @param handler error handler
     */
    onError(handler: ErrorHandler): void;
    /**
     * Trigger all registered error handlers
     * @param error thrown error
     * @param shouldThrow set to false to not throw the error
     */
    private triggerError;
    private updateReactiveRoute;
}
export {};
