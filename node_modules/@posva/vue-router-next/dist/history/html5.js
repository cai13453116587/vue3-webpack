"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const consola_1 = __importDefault(require("consola"));
const base_1 = require("./base");
const base_2 = require("./base");
const cs = consola_1.default.withTag('html5');
// TODO: implement the mock instead
/* istanbul ignore next */
// @ts-ignore
if (process.env.NODE_ENV === 'test')
    cs.mockTypes(() => jest.fn());
// TODO: pretty useless right now except for typing
function buildState(back, current, forward, replaced = false) {
    return {
        back,
        current,
        forward,
        replaced,
    };
}
class HTML5History extends base_1.BaseHistory {
    constructor() {
        super();
        this.history = window.history;
        this._listeners = [];
        this._teardowns = [];
        // TODO: should it be a stack? a Dict. Check if the popstate listener
        // can trigger twice
        this.pauseState = null;
        const to = buildFullPath();
        // cs.log('created', to)
        this.history.replaceState(buildState(null, to, null), '', to.fullPath);
        this.location = to;
        this._popStateHandler = this.setupPopStateListener();
    }
    // TODO: is this necessary
    ensureLocation() { }
    replace(to) {
        const normalized = this.utils.normalizeLocation(to);
        if (normalized.fullPath === this.location.fullPath)
            return;
        cs.info('replace', this.location, normalized);
        this.history.replaceState(
        // TODO: this should be user's responsibility
        // _replacedState: this.history.state || null,
        buildState(this.history.state.back, normalized, null, true), '', normalized.fullPath);
        this.location = normalized;
    }
    push(to, data) {
        // replace current entry state to add the forward value
        // TODO: should be removed and let the user normalize the location?
        // or make it fast so normalization on a normalized object is fast
        const normalized = this.utils.normalizeLocation(to);
        this.history.replaceState(buildState(this.history.state.back, this.history.state.current, normalized, this.history.state.replaced), '');
        // TODO: compare current location to prevent navigation
        // NEW NOTE: I think it shouldn't be history responsibility to check that
        // if (to === this.location) return
        const state = {
            ...buildState(this.location, normalized, null),
            ...data,
        };
        cs.info('push', this.location, '->', normalized, 'with state', state);
        this.history.pushState(state, '', normalized.fullPath);
        this.location = normalized;
    }
    back(triggerListeners = true) {
        // TODO: check if we can go back
        const previvousLocation = this.history.state
            .back;
        if (!triggerListeners)
            this.pauseListeners(previvousLocation);
        this.history.back();
    }
    forward(triggerListeners = true) {
        // TODO: check if we can go forward
        const previvousLocation = this.history.state
            .forward;
        if (!previvousLocation)
            throw new Error('Cannot go forward');
        if (!triggerListeners)
            this.pauseListeners(previvousLocation);
        this.history.forward();
    }
    listen(callback) {
        // settup the listener and prepare teardown callbacks
        this._listeners.push(callback);
        const teardown = () => {
            this._listeners.splice(this._listeners.indexOf(callback), 1);
        };
        this._teardowns.push(teardown);
        return teardown;
    }
    /**
     * Remove all listeners attached to the history and cleanups the history
     * instance
     */
    destroy() {
        for (const teardown of this._teardowns)
            teardown();
        this._teardowns = [];
        if (this._popStateHandler)
            window.removeEventListener('popstate', this._popStateHandler);
    }
    /**
     * Setups the popstate event listener. It's important to setup only
     * one to ensure the same parameters are passed to every listener
     */
    setupPopStateListener() {
        const handler = ({ state }) => {
            cs.info('popstate fired', {
                state,
                location: this.location,
            });
            // TODO: handle go(-2) and go(2) (skipping entries)
            const from = this.location;
            // we have the state from the old entry, not the current one being removed
            // TODO: correctly parse pathname
            const to = state ? state.current : buildFullPath();
            this.location = to;
            if (this.pauseState &&
                this.pauseState.to &&
                this.pauseState.to.fullPath === to.fullPath) {
                cs.info('Ignored beacuse paused');
                // reset pauseState
                this.pauseState = null;
                return;
            }
            // call all listeners
            const navigationInfo = {
                direction: state.forward && from.fullPath === state.forward.fullPath
                    ? base_2.NavigationDirection.back
                    : base_2.NavigationDirection.forward,
            };
            this._listeners.forEach(listener => listener(this.location, from, navigationInfo));
        };
        // settup the listener and prepare teardown callbacks
        window.addEventListener('popstate', handler);
        return handler;
    }
    pauseListeners(to) {
        this.pauseState = {
            currentLocation: this.location,
            to,
        };
    }
}
exports.HTML5History = HTML5History;
const buildFullPath = () => {
    const { location } = window;
    return {
        fullPath: location.pathname + location.search + location.hash,
        path: location.pathname,
        query: {},
        hash: location.hash,
    };
};
//# sourceMappingURL=html5.js.map