"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PERCENT_RE = /%/g;
/**
 * Transforms a URL into an object
 * @param location location to normalize
 * @param currentLocation current location, to reuse params and location
 */
function parseURL(location) {
    let path = '', query = {}, searchString = '', hash = '';
    // Could use URL and URLSearchParams but IE 11 doesn't support it
    const searchPos = location.indexOf('?');
    const hashPos = location.indexOf('#', searchPos > -1 ? searchPos : 0);
    if (searchPos > -1) {
        path = location.slice(0, searchPos);
        searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);
        query = parseQuery(searchString);
    }
    if (hashPos > -1) {
        path = path || location.slice(0, hashPos);
        hash = location.slice(hashPos, location.length);
    }
    path = path || location;
    return {
        fullPath: location,
        path,
        query,
        hash,
    };
}
exports.parseURL = parseURL;
/**
 * Transform a queryString into a query object. Accept both, a version with the leading `?` and without
 * Should work as URLSearchParams
 * @param search
 */
function parseQuery(search) {
    const hasLeadingIM = search[0] === '?';
    const query = {};
    const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');
    for (let i = 0; i < searchParams.length; ++i) {
        const [key, value] = searchParams[i].split('=');
        if (key in query) {
            // an extra variable for ts types
            let currentValue = query[key];
            if (!Array.isArray(currentValue)) {
                currentValue = query[key] = [currentValue];
            }
            currentValue.push(value);
        }
        else {
            query[key] = value;
        }
    }
    return query;
}
exports.parseQuery = parseQuery;
/**
 * Stringify a URL object
 * @param location
 */
function stringifyURL(location) {
    let url = location.path;
    let query = location.query ? stringifyQuery(location.query) : '';
    return url + (query && '?' + query) + (location.hash || '');
}
exports.stringifyURL = stringifyURL;
/**
 * Stringify an object query. Works like URLSearchParams. Doesn't prepend a `?`
 * @param query
 */
function stringifyQuery(query) {
    let search = '';
    // TODO: util function?
    for (const key in query) {
        if (search.length > 1)
            search += '&';
        // TODO: handle array
        const value = query[key];
        if (Array.isArray(value)) {
            search += `${key}=${value[0]}`;
            for (let i = 1; i < value.length; i++) {
                search += `&${key}=${value[i]}`;
            }
        }
        else {
            search += `${key}=${query[key]}`;
        }
    }
    return search;
}
exports.stringifyQuery = stringifyQuery;
function normalizeQuery(query) {
    // TODO: implem
    return query;
}
exports.normalizeQuery = normalizeQuery;
/**
 * Prepare a URI string to be passed to pushState
 * @param uri
 */
function prepareURI(uri) {
    // encode the % symbol so it also works on IE
    return uri.replace(PERCENT_RE, '%25');
}
exports.prepareURI = prepareURI;
// use regular decodeURI
exports.decodeURI = global.decodeURI;
/**
 * Normalize a History location into an object that looks like
 * the one at window.location
 * @param location
 */
function normalizeLocation(location) {
    if (typeof location === 'string')
        return parseURL(location);
    else
        return {
            fullPath: stringifyURL(location),
            path: location.path,
            query: location.query ? normalizeQuery(location.query) : {},
            hash: location.hash || '',
        };
}
exports.normalizeLocation = normalizeLocation;
//# sourceMappingURL=utils.js.map