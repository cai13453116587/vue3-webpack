import { HistoryQuery, RawHistoryQuery } from '../history/base';
export declare type Lazy<T> = () => Promise<T>;
export declare type TODO = any;
export declare type ListenerRemover = () => void;
export declare type RouteParams = Record<string, string | string[]>;
export interface RouteQueryAndHash {
    query?: RawHistoryQuery;
    hash?: string;
}
export interface LocationAsPath {
    path: string;
}
export interface LocationAsName {
    name: string;
    params?: RouteParams;
}
export interface LocationAsRelative {
    params?: RouteParams;
}
interface RouteLocationOptions {
    replace?: boolean;
}
export declare type RouteLocation = string | RouteQueryAndHash & LocationAsPath & RouteLocationOptions | RouteQueryAndHash & LocationAsName & RouteLocationOptions | RouteQueryAndHash & LocationAsRelative & RouteLocationOptions;
export declare type MatchedRouteRecord = Exclude<RouteRecord, RouteRecordRedirect>;
export interface RouteLocationNormalized extends Required<RouteQueryAndHash & LocationAsRelative & LocationAsPath> {
    fullPath: string;
    query: HistoryQuery;
    name: string | void;
    matched: MatchedRouteRecord[];
    redirectedFrom?: RouteLocationNormalized;
}
export interface RouteComponentInterface {
    beforeRouteEnter?: NavigationGuard<void>;
    /**
     * Guard called when the router is navigating away from the current route
     * that is rendering this component.
     * @param to RouteLocation we are navigating to
     * @param from RouteLocation we are navigating from
     * @param next function to validate, cancel or modify (by redirectering) the navigation
     */
    beforeRouteLeave?: NavigationGuard<void>;
    /**
     * Guard called whenever the route that renders this component has changed but
     * it is reused for the new route. This allows you to guard for changes in params,
     * the query or the hash.
     * @param to RouteLocation we are navigating to
     * @param from RouteLocation we are navigating from
     * @param next function to validate, cancel or modify (by redirectering) the navigation
     */
    beforeRouteUpdate?: NavigationGuard<void>;
}
export declare type RouteComponent = {
    template?: string;
    render?: Function;
} & RouteComponentInterface;
interface RouteRecordCommon {
    path: string;
    name?: string;
    beforeEnter?: NavigationGuard | NavigationGuard[];
}
export declare type RouteRecordRedirectOption = RouteLocation | ((to: RouteLocationNormalized) => RouteLocation);
export interface RouteRecordRedirect extends RouteRecordCommon {
    redirect: RouteRecordRedirectOption;
}
interface RouteRecordSingleView extends RouteRecordCommon {
    component: RouteComponent | Lazy<RouteComponent>;
    children?: RouteRecord[];
}
interface RouteRecordMultipleViews extends RouteRecordCommon {
    components: Record<string, RouteComponent | Lazy<RouteComponent>>;
}
export declare type RouteRecord = RouteRecordSingleView | RouteRecordMultipleViews | RouteRecordRedirect;
export declare const START_LOCATION_NORMALIZED: RouteLocationNormalized;
export declare type MatcherLocation = LocationAsPath | LocationAsName | LocationAsRelative;
export interface MatcherLocationNormalized {
    name: RouteLocationNormalized['name'];
    path: string;
    params: RouteLocationNormalized['params'];
    matched: MatchedRouteRecord[];
    redirectedFrom?: MatcherLocationNormalized;
}
export interface MatcherLocationRedirect {
    redirect: RouteRecordRedirectOption;
    normalizedLocation: MatcherLocationNormalized;
}
export interface NavigationGuardCallback {
    (): void;
    (location: RouteLocation): void;
    (valid: false): void;
}
export interface NavigationGuard<V = void> {
    (this: V, to: RouteLocationNormalized, from: RouteLocationNormalized, next: NavigationGuardCallback): any;
}
export interface PostNavigationGuard {
    (to: RouteLocationNormalized, from: RouteLocationNormalized): any;
}
export {};
