import { LocationQuery, LocationQueryRaw } from '../utils/query';
import { PathParserOptions } from '../matcher/path-parser-ranker';
import { RouteRecordNormalized } from '../matcher/types';
export declare type Lazy<T> = () => Promise<T>;
export declare type Override<T, U> = Pick<T, Exclude<keyof T, keyof U>> & U;
export declare type Immutable<T> = {
    readonly [P in keyof T]: Immutable<T[P]>;
};
export declare type TODO = any;
export declare type ListenerRemover = () => void;
declare type RouteParamValue = string;
export declare type RouteParams = Record<string, RouteParamValue | RouteParamValue[]>;
export declare type RouteParamsRaw = RouteParams;
export interface RouteQueryAndHash {
    query?: LocationQueryRaw;
    hash?: string;
}
export interface LocationAsPath {
    path: string;
}
export interface LocationAsName {
    name: string;
    params?: RouteParamsRaw;
}
export interface LocationAsRelative {
    params?: RouteParams;
}
export interface RouteLocationOptions {
    replace?: boolean;
}
export declare type RouteLocation = string | (RouteQueryAndHash & LocationAsPath & RouteLocationOptions) | (RouteQueryAndHash & LocationAsName & RouteLocationOptions) | (RouteQueryAndHash & LocationAsRelative & RouteLocationOptions);
export interface RouteLocationNormalized {
    path: string;
    fullPath: string;
    query: LocationQuery;
    hash: string;
    name: string | null | undefined;
    params: RouteParams;
    matched: RouteRecordNormalized[];
    redirectedFrom: RouteLocationNormalized | undefined;
    meta: Record<string | number | symbol, any>;
}
export interface RouteComponentInterface {
    beforeRouteEnter?: NavigationGuard<void>;
    /**
     * Guard called when the router is navigating away from the current route
     * that is rendering this component.
     * @param to RouteLocation we are navigating to
     * @param from RouteLocation we are navigating from
     * @param next function to validate, cancel or modify (by redirectering) the navigation
     */
    beforeRouteLeave?: NavigationGuard<void>;
    /**
     * Guard called whenever the route that renders this component has changed but
     * it is reused for the new route. This allows you to guard for changes in params,
     * the query or the hash.
     * @param to RouteLocation we are navigating to
     * @param from RouteLocation we are navigating from
     * @param next function to validate, cancel or modify (by redirectering) the navigation
     */
    beforeRouteUpdate?: NavigationGuard<void>;
}
export declare type RouteComponent = TODO;
export interface RouteRecordCommon {
    path: string;
    alias?: string | string[];
    name?: string;
    beforeEnter?: NavigationGuard | NavigationGuard[];
    meta?: Record<string | number | symbol, any>;
    options?: PathParserOptions;
}
export declare type RouteRecordRedirectOption = RouteLocation | ((to: Immutable<RouteLocationNormalized>) => RouteLocation);
export interface RouteRecordRedirect extends RouteRecordCommon {
    redirect: RouteRecordRedirectOption;
    beforeEnter?: never;
    component?: never;
    components?: never;
}
export interface RouteRecordSingleView extends RouteRecordCommon {
    component: RouteComponent;
    children?: RouteRecord[];
}
export interface RouteRecordMultipleViews extends RouteRecordCommon {
    components: Record<string, RouteComponent>;
    children?: RouteRecord[];
}
export declare type RouteRecord = RouteRecordSingleView | RouteRecordMultipleViews | RouteRecordRedirect;
export declare const START_LOCATION_NORMALIZED: RouteLocationNormalized;
export declare type MatcherLocation = LocationAsPath | LocationAsName | LocationAsRelative;
export interface MatcherLocationNormalized extends Pick<RouteLocationNormalized, 'name' | 'path' | 'params' | 'matched' | 'meta'> {
}
export interface MatcherLocationRedirect {
    redirect: RouteRecordRedirectOption;
    normalizedLocation: MatcherLocationNormalized;
}
export interface NavigationGuardCallback {
    (): void;
    (location: RouteLocation): void;
    (valid: false): void;
    (cb: (vm: any) => void): void;
}
export interface NavigationGuard<V = void> {
    (this: V, to: Immutable<RouteLocationNormalized>, from: Immutable<RouteLocationNormalized>, next: NavigationGuardCallback): any;
}
export interface PostNavigationGuard {
    (to: Immutable<RouteLocationNormalized>, from: Immutable<RouteLocationNormalized>): any;
}
export * from './type-guards';
export declare type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};
